<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Blockly IDE</title>

<script src="https://unpkg.com/blockly/blockly.min.js"></script>
<script src="https://unpkg.com/@blockly/blockly/javascript_compressed.js"></script>

<style>
/* ğŸ¨ CSS æ¨£å¼ï¼šç¢ºä¿æ•´é«”ä½ˆå±€ */
html, body {
    height: 100%; 
    margin: 0; 
    padding: 0; 
    overflow: hidden; 
    font-family: sans-serif;
}
#toolbar {
    height: 40px; 
    background: #eee; 
    border-bottom: 1px solid #ccc; 
    display: flex; 
    align-items: center; 
    padding: 0 10px; 
    box-sizing: border-box;
}
#toolbar button {
    margin-right: 10px;
}

/* ä¸»å®¹å™¨ï¼šå·¦å³åˆ†å‰² */
#main {
    display: flex; 
    height: calc(100% - 40px);
}

/* å·¦å´ï¼šBlockly å·¥ä½œå€ */
#blocklyDiv {
    flex: 0 0 70%; 
    height: 100%;
    min-width: 100px;
    max-width: calc(100% - 100px); 
    transition: none;
}

/* æ‹–æ›³åˆ†å‰²ç·š (æ°´å¹³) */
#resizer {
    width: 6px;
    height: 100%;
    background-color: #ccc;
    cursor: col-resize;
    flex-shrink: 0;
}

/* å³å´ä¸»å®¹å™¨ï¼šä¸Šä¸‹åˆ†å‰² */
#rightPanel {
    flex: 1; 
    display: flex;
    flex-direction: column;
    height: 100%;
    min-width: 100px;
}

/* å³å´ï¼šä¸Šä¸‹å­è¦–çª—çš„å…±åŒæ¨£å¼ */
.panel-section {
    padding: 10px;
    box-sizing: border-box;
    font-family: monospace;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* ä¸ŠåŠéƒ¨ï¼šInput (é‡è¦ï¼šè¨­å®š flex-grow å’Œåˆå§‹ height) */
#inputPanel {
    flex-grow: 0; 
    flex-shrink: 0;
    border-bottom: 1px solid #ccc;
    background-color: #f8f8f8;
    height: 33%; 
}

#ansPanel {
    flex-grow: 0; 
    flex-shrink: 0;
    border-bottom: 1px solid #ccc;
    background-color: #f8f8f8;
    height: 33%; 
}

/* ä¸‹åŠéƒ¨ï¼šOutput (é‡è¦ï¼šè¨­å®š flex-grow å’Œåˆå§‹ height) */
#outputPanel {
    flex-grow: 0; 
    flex-shrink: 0;
    background-color: #000;
    color: #0f0; 
    overflow-y: auto;
    white-space: pre-wrap;
    height: calc(33% - 10px);
}

/* å‚ç›´æ‹–æ›³åˆ†å‰²ç·šæ¨£å¼ */
#v-resizer {
    height: 6px; 
    width: 100%;
    background-color: #aaa;
    cursor: row-resize; 
    flex-shrink: 0;
}

/* æ¨™é¡Œæ¨£å¼ */
.panel-caption {
    font-size: 0.9em;
    font-weight: bold;
    margin-bottom: 5px;
    color: #666;
    text-transform: uppercase;
    flex-shrink: 0;
}
#outputPanel .panel-caption {
     color: #eee;
}

/* å¯¦éš›çš„è¼¸å…¥/è¼¸å‡ºå…§å®¹å€ */
#inputContent {
    flex-grow: 1; 
    border: 1px solid #ddd;
    padding: 5px;
    overflow: auto;
    background-color: white;
    resize: none; 
}
#ansContent {
    flex-grow: 1; 
    border: 1px solid #ddd;
    padding: 5px;
    overflow: auto;
    background-color: white;
    resize: none; 
}

#outputContent {
    flex-grow: 1;
    background-color: transparent;
    border: none;
    padding: 0;
}

/* **ã€Modal æ¨£å¼ã€‘** */
/* æ•´å€‹é®ç½© */
#descModal {
    position: fixed;       /* å›ºå®šæ–¼è¦–çª— */
    top: 0;
    left: 0;
    width: 100vw;          /* æ»¿ç‰ˆå¯¬åº¦ */
    height: 100vh;         /* æ»¿ç‰ˆé«˜åº¦ */
    background-color: rgba(0, 0, 0, 0.5); /* åŠé€æ˜é»‘èƒŒæ™¯ */
    display: flex;         /* flex ç½®ä¸­ modal-content */
    justify-content: center; /* æ°´å¹³ç½®ä¸­ */
    align-items: center;     /* å‚ç›´ç½®ä¸­ */
    z-index: 1000;         /* ç¢ºä¿åœ¨æœ€ä¸Šå±¤ */
}

/* å…§éƒ¨å…§å®¹æ¡† */
#descModal .modal-content {
    background-color: #fcf8e3; /* <-- å·²ä¿®æ”¹ç‚ºæ·¡é‡‘è‰² (æˆ–æ‚¨ä¹Ÿå¯ä»¥ç”¨ #fafad2) */
    padding: 10px 20px 20px 20px;
    border-radius: 8px;
    max-width: 600px;       /* æœ€å¤§å¯¬åº¦ */
    width: 90%;             /* ä¾è¦–çª—ç¸®æ”¾ */
    max-height: 80vh;       /* é«˜åº¦é™åˆ¶ï¼Œé¿å…è¶…å‡ºè¦–çª— */
    overflow: auto;         /* å…§å®¹éå¤šæ™‚é¡¯ç¤ºæ»¾å‹•æ¢ */
    white-space: pre-wrap;  /* ä¿ç•™æ›è¡Œ */
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}
    
#shareModal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

#modalContent {
    background: white;
    padding: 25px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    width: 90%;
    max-width: 500px;
    text-align: center;
}

#shareUrlInput {
    width: 95%;
    padding: 8px;
    margin: 15px 0;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 0.9em;
    cursor: text;
    user-select: all;
}

.modal-buttons button {
    padding: 10px 15px;
    margin: 5px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
}

.modal-buttons button:first-child {
    background-color: #007bff;
    color: white;
}

.modal-buttons button:last-child {
    background-color: #ccc;
}
</style>
</head>
<body>

<div id="toolbar">
  <button onclick="exportXML()">åŒ¯å‡º XML</button>
  <button onclick="importXML()">åŒ¯å…¥ XML</button>
  <button onclick="shareLink()">åˆ†äº«</button> 
  <button onclick="runCode()">åŸ·è¡Œç¨‹å¼ç¢¼</button>
  <button id="langButton" onclick="switchLanguage()">åˆ‡æ›èªè¨€ (English)</button>
  <button onclick="showDescription()">é¡Œç›®èªªæ˜</button>
</div>

<div id="main">
  <div id="blocklyDiv"></div>
  <div id="resizer"></div>
  
  <div id="rightPanel">
    <div id="inputPanel" class="panel-section">
        <div class="panel-caption">Input (æ¯è¡Œè¦–ç‚ºä¸€æ¬¡è¼¸å…¥):</div>
        <textarea id="inputContent" placeholder="åœ¨æ­¤è¼¸å…¥ç¨‹å¼æ‰€éœ€çš„è³‡æ–™ï¼Œæ¯è¡Œä¸€å€‹å€¼..." rows="5"></textarea>
    </div>
    
    <div id="v-resizer"></div> 

    <div id="ansPanel" class="panel-section">
        <div class="panel-caption">Answer (æ¨™æº–ç­”æ¡ˆ):</div>
        <textarea id="ansContent" placeholder="" rows="5"></textarea>
    </div>


    <div id="v-resizer"></div> 

    <div id="outputPanel" class="panel-section">
        <div class="panel-caption">Output:</div>
        <pre id="outputContent">ç¨‹å¼åŸ·è¡Œçµæœå°‡é¡¯ç¤ºåœ¨é€™è£¡...</pre>
    </div>
  </div>
</div>
  
<div id="shareModal" style="display: none;">
    <div id="modalContent">
        <h3>ğŸ‰ å°ˆæ¡ˆåˆ†äº«é€£çµ</h3>
        <p>æ­¤é€£çµåŒ…å«æ‚¨çš„ Blockly å°ˆæ¡ˆå…§å®¹ã€‚**è«‹æ³¨æ„ï¼š** è‹¥è¦è®“æ­¤é€£çµå°ä»–äººæœ‰æ•ˆï¼Œæ‚¨å¿…é ˆå°‡æ­¤ HTML æª”æ¡ˆç™¼ä½ˆåˆ°ç¶²ç«™ä¼ºæœå™¨ (Server) ä¸Šã€‚</p>
        <input type="text" id="shareUrlInput" readonly>
        <div class="modal-buttons">
            <button onclick="copyShareUrl()">è¤‡è£½é€£çµ</button>
            <button onclick="closeModal()">é—œé–‰</button>
        </div>
        <p style="font-size:0.85em; margin-top:15px; color:#c00;">[æœ¬åœ°æ–‡ä»¶è­¦å‘Š] å¦‚æœæ‚¨ç›´æ¥å¾æœ¬åœ°æ–‡ä»¶ï¼ˆä¾‹å¦‚ C:\ï¼‰é–‹å•Ÿæ­¤æª”æ¡ˆï¼Œåˆ†äº«é€£çµå°‡æœƒç„¡æ•ˆï¼</p>
    </div>
</div>

<div id="descModal"  style="display:none;">
    <div class="modal-content" style="white-space: pre-wrap; overflow: auto; max-height: 80vh;">
        <h2 id="descTitle"></h2>
        <pre id="descText" style="white-space: pre-wrap;"></pre>
        <button onclick="closeDescModal()" style="margin-top:10px;">é—œé–‰</button>
    </div>
</div>
    
<script>
  // **ã€å…¨åŸŸè®Šæ•¸ã€‘**
  let currentId = null;
  let workspace;
  let currentLanguage = 'zh-hant';
  let isResizing = false;
  let lastBlocklyWidth = '0 0 70%';

  const langButton = document.getElementById('langButton');
  const main = document.getElementById('main');
  const blocklyDiv = document.getElementById('blocklyDiv');
  const outputContent = document.getElementById('outputContent');
  const inputContent = document.getElementById('inputContent');

  // **XML å…¼å®¹æ€§ä¿®å¾©** (ä¿æŒä¸è®Š)
  if (Blockly.utils && Blockly.utils.xml) {
    Blockly.Xml = {
      domToText: Blockly.utils.xml.domToText,
      domToPrettyText: Blockly.utils.xml.domToPrettyText,
      textToDom: Blockly.utils.xml.textToDom,
      domToWorkspace: Blockly.Xml.domToWorkspace,
      workspaceToDom: Blockly.Xml.workspaceToDom
    };
  }
  
  // **å·¥å…·ç®±å®šç¾© (åŠ å…¥é¡è‰²å±¬æ€§)**
  function getToolbox(lang) {
    const categories = {
      'zh-hant': ['é‚è¼¯', 'è¿´åœˆ', 'æ•¸å­¸', 'æ–‡å­—', 'æ¸…å–®', 'è®Šæ•¸', 'å‡½å¼'],
      'en': ['Logic', 'Loops', 'Math', 'Text', 'Lists', 'Variables', 'Functions']
    };
    
    const langNames = categories[lang] || categories['zh-hant'];

    return {
      "kind": "categoryToolbox",
      "contents": [
        {"kind": "category", "name": langNames[0], "colour": "210", "contents": [ /* é‚è¼¯ (è—) */
          {"kind":"block","type":"controls_if"}, {"kind":"block","type":"logic_compare"},
          {"kind":"block","type":"logic_operation"}, {"kind":"block","type":"logic_boolean"},
          {"kind":"block","type":"logic_negate"}, {"kind":"block","type":"logic_null"},
          {"kind":"block","type":"logic_ternary"}
        ]},
        {"kind": "category", "name": langNames[1], "colour": "120", "contents": [ /* è¿´åœˆ (ç¶ ) */
          {"kind":"block","type":"controls_repeat_ext"}, {"kind":"block","type":"controls_whileUntil"},
          {"kind":"block","type":"controls_for"}, {"kind":"block","type":"controls_forEach"},
          {"kind":"block","type":"controls_flow_statements"}
        ]},
        {"kind": "category", "name": langNames[2], "colour": "230", "contents": [ /* æ•¸å­¸ (æ·±è—) */
          {"kind":"block","type":"math_number"}, {"kind":"block","type":"math_arithmetic"},
          {"kind":"block","type":"math_single"}, {"kind":"block","type":"math_trig"},
          {"kind":"block","type":"math_constant"}, {"kind":"block","type":"math_number_property"},
          {"kind":"block","type":"math_round"}, {"kind":"block","type":"math_on_list"},
          {"kind":"block","type":"math_modulo"}, {"kind":"block","type":"math_constrain"},
          {"kind":"block","type":"math_random_int"}, {"kind":"block","type":"math_random_float"},
          {"kind":"block","type":"math_atan2"}
        ]},
        {"kind": "category", "name": langNames[3], "colour": "160", "contents": [ /* æ–‡å­— (é’) */
          {"kind":"block","type":"text"}, {"kind":"block","type":"text_join"},
          {"kind":"block","type":"text_append"}, {"kind":"block","type":"text_length"},
          {"kind":"block","type":"text_isEmpty"}, {"kind":"block","type":"text_indexOf"},
          {"kind":"block","type":"text_charAt"}, {"kind":"block","type":"text_getSubstring"},
          {"kind":"block","type":"text_changeCase"}, {"kind":"block","type":"text_trim"},
          {"kind":"block","type":"text_print"}, 
          {"kind":"block","type":"text_prompt_ext"}
        ]},
        {"kind": "category", "name": langNames[4], "colour": "300", "contents": [ /* æ¸…å–® (ç´«) */
          {"kind":"block","type":"lists_create_with"}, {"kind":"block","type":"lists_repeat"},
          {"kind":"block","type":"lists_length"}, {"kind":"block","type":"lists_isEmpty"},
          {"kind":"block","type":"lists_indexOf"}, {"kind":"block","type":"lists_getIndex"},
          {"kind":"block","type":"lists_setIndex"}, {"kind":"block","type":"lists_getSublist"},
          {"kind":"block","type":"lists_split"}, {"kind":"block","type":"lists_sort"}
        ]},
        {"kind": "category", "name": langNames[5], "colour": "330", "custom": "VARIABLE"}, /* è®Šæ•¸ (ç´…) */
        {"kind": "category", "name": langNames[6], "colour": "290", "custom": "PROCEDURE"} /* å‡½å¼ (æ·±ç´«) */
      ]
    };
  }

  // **è¼‰å…¥èªè¨€/å·¥ä½œå€ (å·²æ›´æ–° Zoom é…ç½®)**
  function loadLanguage(languageCode) {
    currentLanguage = languageCode;
    let xmlText = '';
    
    if (workspace) {
        const xml = Blockly.Xml.workspaceToDom(workspace);
        xmlText = Blockly.Xml.domToText(xml);
        workspace.dispose();
    }
    
    const oldScript = document.getElementById('langScript');
    if (oldScript) oldScript.remove();
    
    const script = document.createElement('script');
    script.src = `https://unpkg.com/blockly/msg/${languageCode}.js`;
    script.id = 'langScript';
    
    script.onload = () => {
        if (languageCode === 'zh-hant') {
            langButton.textContent = 'åˆ‡æ›èªè¨€ (English)';
        } else {
            langButton.textContent = 'Switch Language (ä¸­æ–‡)';
        }
        
        const toolbox = getToolbox(languageCode);
        const injectConfig = {
            toolbox: toolbox,
            scrollbars: true,
            trashcan: true,
            collapse: true,
            grid: {spacing: 20, length: 3, colour: '#ccc', snap: true},
            locale: languageCode,
            
            // **ã€æ–°å¢ã€‘æ”¾å¤§ç¸®å°é…ç½®**
            zoom: {
                controls: true, // é¡¯ç¤ºå³ä¸‹è§’çš„æ”¾å¤§/ç¸®å°/é©æ‡‰è¦–çª—æŒ‰éˆ•
                wheel: false,    // å•Ÿç”¨æ»‘é¼ æ»¾è¼ªç¸®æ”¾
                startScale: 1.0, 
                maxScale: 3,
                minScale: 0.3,
                scaleSpeed: 1.2
            }
        };
        workspace = Blockly.inject('blocklyDiv', injectConfig);
        
        if (xmlText) {
            try {
                const dom = Blockly.Xml.textToDom(xmlText);
                Blockly.Xml.domToWorkspace(dom, workspace);
            } catch(e) {
                console.warn("ç„¡æ³•æ¢å¾©å·¥ä½œå€ XML:", e);
            }
        }
        
        Blockly.svgResize(workspace);
    };
    
    document.head.appendChild(script);
  }

  // **åˆ‡æ›èªè¨€å‡½æ•¸**
  function switchLanguage() {
    const targetLang = currentLanguage === 'zh-hant' ? 'en' : 'zh-hant';
    loadLanguage(targetLang);
  }

  // **æ‹–æ›³åˆ†å‰²ç·šé‚è¼¯ (æ°´å¹³ï¼šBlockly å’Œ I/O)**
  function enableResize() {
    const resizer = document.getElementById('resizer');
    
    resizer.addEventListener('mousedown', function(e) {
      isResizing = true;
      document.body.style.userSelect = 'none';
      document.body.style.cursor = 'col-resize';
    });

    document.addEventListener('mousemove', function(e) {
      if (!isResizing) return;

      const totalWidth = main.offsetWidth;
      let newBlocklyWidth = e.clientX - main.offsetLeft; 
      
      const minWidth = 100;
      if (newBlocklyWidth < minWidth) {
          newBlocklyWidth = minWidth;
      } else if (totalWidth - newBlocklyWidth - resizer.offsetWidth < minWidth) {
          newBlocklyWidth = totalWidth - minWidth - resizer.offsetWidth;
      }

      const newFlexValue = '0 0 ' + newBlocklyWidth + 'px';
      blocklyDiv.style.flex = newFlexValue;
      lastBlocklyWidth = newFlexValue;
      
      Blockly.svgResize(workspace);
    });

    document.addEventListener('mouseup', function() {
      if (isResizing) {
        isResizing = false;
        document.body.style.userSelect = 'auto';
        document.body.style.cursor = 'default';
      }
    });
  }

  // **å‚ç›´æ‹–æ›³åˆ†å‰²ç·šé‚è¼¯ (Input å’Œ Output)**
  function enableVResize() {
    const vResizer = document.getElementById('v-resizer');
    const rightPanel = document.getElementById('rightPanel');
    const inputPanel = document.getElementById('inputPanel');
    const outputPanel = document.getElementById('outputPanel');
    let isVResizing = false;

    vResizer.addEventListener('mousedown', function(e) {
      isVResizing = true;
      document.body.style.userSelect = 'none';
      document.body.style.cursor = 'row-resize';
    });

    document.addEventListener('mousemove', function(e) {
      if (!isVResizing) return;

      const rightPanelRect = rightPanel.getBoundingClientRect();
      let newInputHeight = e.clientY - rightPanelRect.top;
      
      const minHeight = 50;

      if (newInputHeight < minHeight) {
          newInputHeight = minHeight;
      } else if (rightPanelRect.height - newInputHeight - vResizer.offsetHeight < minHeight) {
          newInputHeight = rightPanelRect.height - minHeight - vResizer.offsetHeight;
      }

      inputPanel.style.height = newInputHeight + 'px';
      outputPanel.style.height = (rightPanelRect.height - newInputHeight - vResizer.offsetHeight) + 'px';
    });

    document.addEventListener('mouseup', function() {
      if (isVResizing) {
        isVResizing = false;
        document.body.style.userSelect = 'auto';
        document.body.style.cursor = 'default';
      }
    });
  }


  // **åŸ·è¡Œç¨‹å¼ç¢¼ï¼šå¯¦ç¾ Readline å’Œ Print** (ä¿æŒä¸è®Š)
  function runCode(){
    outputContent.textContent = "åŸ·è¡Œä¸­...\n";
    
    let inputLines = inputContent.value.split('\n')
                                     .map(line => line.trimEnd())
                                     .filter(line => line !== "");
    let inputIndex = 0;
    const startTime = performance.now(); // âœ… é–‹å§‹è¨ˆæ™‚
    const customAlert = (message) => {
        outputContent.textContent += (String(message) + '\n');
        outputContent.scrollTop = outputContent.scrollHeight;
    };

    const customPrompt = (message, defaultValue) => {
        //outputContent.textContent += `[Input Request]: ${message || "è«‹è¼¸å…¥å€¼"}\n`;

        if (inputIndex < inputLines.length) {
            const input = inputLines[inputIndex];
            inputIndex++;
            //outputContent.textContent += `[Input Used]: "${input}"\n`;
            //outputContent.scrollTop = outputContent.scrollHeight;
            return input;
        } else {
            const finalValue = (defaultValue === undefined) ? null : defaultValue;
            outputContent.textContent += `[Input exhausted, using default/null: ${finalValue}]\n`;
            outputContent.scrollTop = outputContent.scrollHeight;
            return finalValue; 
        }
    };
    
    const originalAlert = window.alert;
    const originalPrompt = window.prompt;
    window.alert = customAlert;
    window.prompt = customPrompt;

    try{
        const code = Blockly.JavaScript.workspaceToCode(workspace);
        eval(code); 
        outputContent.textContent += "\n--- ç¨‹å¼åŸ·è¡Œå®Œç•¢ ---";
    }
    catch(e){
        outputContent.textContent += "\n\n!!! ç¨‹å¼åŸ·è¡ŒéŒ¯èª¤:\n" + e;
    }
    finally {
        window.alert = originalAlert;
        window.prompt = originalPrompt;
        
        const endTime = performance.now(); // âœ… çµæŸæ™‚é–“
        const elapsed = ((endTime - startTime) / 1000).toFixed(4);
        outputContent.textContent += `â± åŸ·è¡Œæ™‚é–“ï¼š${elapsed} ç§’`;
        
         
        outputContent.scrollTop = outputContent.scrollHeight;
    }
  }
  
  // **Modal ç›¸é—œå‡½æ•¸** (ä¿æŒä¸è®Š)
  function openModal(url) {
      document.getElementById('shareUrlInput').value = url;
      document.getElementById('shareModal').style.display = 'flex';
  }

  function closeModal() {
      document.getElementById('shareUrlInput').value = '';
      document.getElementById('shareModal').style.display = 'none';
  }

  function copyShareUrl() {
      const urlInput = document.getElementById('shareUrlInput');
      urlInput.select();
      urlInput.setSelectionRange(0, 99999);
      
      try {
          navigator.clipboard.writeText(urlInput.value)
              .then(() => {
                  alert("é€£çµå·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼");
              })
              .catch(err => {
                  console.error("è¤‡è£½åˆ°å‰ªè²¼ç°¿å¤±æ•—:", err);
                  alert("è¤‡è£½å¤±æ•—ï¼Œè«‹æ‰‹å‹•é¸å–ä¸¦è¤‡è£½è¦–çª—ä¸­çš„é€£çµã€‚");
              });
      } catch (err) {
          document.execCommand('copy');
          alert("é€£çµå·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼");
      }
  }
  
  // **åˆ†äº«é€£çµ** (ä¿æŒä¸è®Š)
  function shareLink(){
    if (!workspace) return alert("å·¥ä½œå€å°šæœªè¼‰å…¥ï¼Œç„¡æ³•åˆ†äº«ã€‚");
    
    const xml = Blockly.Xml.workspaceToDom(workspace);
    const text = Blockly.Xml.domToText(xml);
    
    const encoded = btoa(text);
    const url = location.origin + location.pathname + "#xml=" + encoded;
    
    openModal(url);
  }

  // åŒ¯å‡º XML (ä¿æŒä¸è®Š)
  function exportXML(){
    if (!workspace) return alert("å·¥ä½œå€å°šæœªè¼‰å…¥ã€‚");
    const xmlDom = Blockly.Xml.workspaceToDom(workspace);
    const serializer = new XMLSerializer();
    let xmlText = serializer.serializeToString(xmlDom);
    if (xmlText.length > 0 && Blockly.Xml && Blockly.Xml.domToPrettyText) {
        try { xmlText = Blockly.Xml.domToPrettyText(xmlDom); } 
        catch(e) { console.warn("ä½¿ç”¨ domToPrettyText å¤±æ•—:", e); }
    }
    const blob = new Blob([xmlText],{type:"text/xml"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "blockly.xml";
    a.click();
    URL.revokeObjectURL(a.href);
  }

  // åŒ¯å…¥ XML (ä¿æŒä¸è®Š)
  function importXML() {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".xml";
    input.onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      file.text().then(text => {
        try {
          const dom = Blockly.Xml.textToDom(text);
          workspace.clear();
          Blockly.Xml.domToWorkspace(dom, workspace);
          alert("åŒ¯å…¥æˆåŠŸï¼");
        } catch(err) {
          console.error(err);
          alert("åŒ¯å…¥å¤±æ•—ï¼šXML ç„¡æ•ˆ\n" + err);
        }
      }).catch(err => {
        console.error(err);
        alert("è®€å–æª”æ¡ˆå¤±æ•—ï¼š" + err);
      });
    };
    input.click();
  }
  
  function showDescription() {
    // å–å¾— URL id
    const params = new URLSearchParams(window.location.search);
    let id = params.get("id");

    // URL æ²’æœ‰ id â†’ ç”¨ currentId
    if (!id) id = currentId;

    // å…©å€‹éƒ½æ²’æœ‰ â†’ ç„¡æ³•è®€é¡Œç›®
    if (!id) {
        alert("æ²’æœ‰é¡Œç›® IDï¼");
        return;
    }

    // æ›´æ–° currentIdï¼ˆç¢ºä¿å…¨åŸŸä¸€è‡´ï¼‰
    currentId = id;

    // å…ˆæŠŠ ID é¡¯ç¤ºåˆ° Output panel
    const outputContent = document.getElementById("outputContent");
    outputContent.textContent = `ç›®å‰é¡Œç›® ID: ${id}\n`;

    // åŠ  timestamp é˜²å¿«å–
    const xmlPath = `set/${id}.xml?t=${Date.now()}`;

    fetch(xmlPath)
        .then(res => {
            if (!res.ok) throw new Error("XML è®€å–å¤±æ•—");
            outputContent.textContent += "è®€å– XML æˆåŠŸï¼\n";
            return res.text();
        })
        .then(str => (new DOMParser()).parseFromString(str, "text/xml"))
        .then(xml => {
            const titleNode = xml.querySelector("title");
            const descNode  = xml.querySelector("description");

            const title = titleNode ? titleNode.textContent.trim() : "ï¼ˆç„¡æ¨™é¡Œï¼‰";
            const desc  = descNode ? descNode.textContent.trim() : "ï¼ˆç„¡èªªæ˜ï¼‰";

            //outputContent.textContent += `æ¨™é¡Œ: ${title}\nèªªæ˜:\n${desc}\n`;

            // é¡¯ç¤º descModal
            document.getElementById("descTitle").innerText = title;
            document.getElementById("descText").innerText  = desc;
            document.getElementById("descModal").style.display = "flex";
        })
        .catch(err => {
            console.error(err);
            //outputContent.textContent += "è®€å– XML å¤±æ•—ï¼\n";
            alert("è®€å–é¡Œç›®èªªæ˜å¤±æ•—ï¼");
        });
}

// é—œé–‰ Modal
function closeDescModal() {
    document.getElementById("descModal").style.display = "none";
}


  function loadIOFromId() {
    const params = new URLSearchParams(window.location.search);
    
    // âœ… å„ªå…ˆç”¨ URL çš„ idï¼ˆå› ç‚ºæ¯é¡Œéƒ½æ˜¯ç”¨ train.html?id=xxxx é–‹å•Ÿï¼‰
    let id = params.get("id");

    // âœ… å¦‚æœ URL æ²’æœ‰ idï¼Œå°±ç”¨ä¹‹å‰çš„ currentIdï¼ˆä¾‹å¦‚é¡Œç›®åˆ‡æ›ï¼‰
    if (!id) id = currentId;

    // âœ… å¦‚æœå…©å€‹éƒ½æ²’æœ‰ â†’ çµæŸ
    if (!id) return;

    // âœ… æœ€çµ‚æŠŠ currentId æ›´æ–°æˆæœ€æ–° id
    currentId = id;

    const ts = Date.now();
    const inputPath = `set/${id}.in?ts=${ts}`;
    const ansPath   = `set/${id}.out?ts=${ts}`;

    fetch(inputPath, { cache: "no-store" })
        .then(r => r.text())
        .then(text => document.getElementById("inputContent").value = text)
        .catch(console.error);

    fetch(ansPath, { cache: "no-store" })
        .then(r => r.text())
        .then(text => document.getElementById("ansContent").value = text)
        .catch(console.error);
}

  // åˆå§‹è¼‰å…¥
  window.onload = ()=>{
    enableResize();  // å•Ÿç”¨å·¦å³å¯¬åº¦æ‹–æ›³
    enableVResize(); // å•Ÿç”¨å‚ç›´é«˜åº¦æ‹–æ›³
    loadLanguage('zh-hant');

    blocklyDiv.style.flex = lastBlocklyWidth;
    const params = new URLSearchParams(window.location.search);
    currentId = params.get("id") || null;

    // ğŸš€ è‡ªå‹•è¼‰å…¥ Input/Answer
    if(currentId) loadIOFromId();
      
    // å¾ URL hash è¼‰å…¥ XML
    if(location.hash.startsWith("#xml=")){
      setTimeout(() => {
        if (!workspace) return;
        const encoded = location.hash.slice(5);
        try{
          const xmlText = atob(encoded);
          const dom = Blockly.Xml.textToDom(xmlText);
          Blockly.Xml.domToWorkspace(dom, workspace);
        } catch(err){console.error("URL XML ç„¡æ•ˆ");}
      }, 500);
    }
  };
</script>

</body>

</html>


























