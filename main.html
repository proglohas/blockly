<!DOCTYPE html>
<html>
<head>
<link rel="icon" type="image/png" href="favicon.png">
<link rel="shortcut icon" href="favicon.png">
<meta charset="utf-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>David's Blockly Lab</title>
<style>
/* 清爽淡藍的背景 */
body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    padding: 30px;
    background-color: #F0F8FF; /* 淡藍色 (AliceBlue) */
    color: #333; /* 預設文字顏色 */
    margin: 0;
}

h1 {
    margin-bottom: 20px;
    color: #007bff; /* 標題顏色 */
    border-bottom: 2px solid #007bff; /* 標題下方加強分隔線 */
    padding-bottom: 10px;
    /* 讓 h1 內容靠右對齊 */
    text-align: right; 
    /* 確保 h1 內容可以靠右對齊 (例如，如果內容是複合的) */
    display: flex;
    justify-content: space-between; /* 在左右兩邊放置元素 */
    align-items: flex-end; /* 將內容放在底部，與分隔線對齊 */
    flex-wrap: wrap; /* 避免在小螢幕上溢出 */
}

/* 確保主要的 "題目列表" 標題靠左 */
h1 span.title-main {
    text-align: left;
    flex-grow: 1; /* 讓它佔用剩餘空間 */
    color: #333; /* 可以選擇讓主標題使用深色以增加區分 */
    font-size: 1.2em; /* 稍微小一點 */
}

/* 讓右側的資訊可以垂直排列 */
h1 div.title-info {
    text-align: right;
    display: flex;
    flex-direction: column; /* 垂直堆疊子元素 */
    align-items: flex-end; /* 讓內部元素靠右對齊 */
}

/* proglohas@gmail.com 的樣式 */
h1 span.title-email {
    color: #555; /* 使用較柔和的顏色 */
    font-size: 0.7em; /* 更小的字體 */
    margin-bottom: 5px; /* 與下方的文字有一點間隔 */
}

/* 旭光高中練習用的樣式 */
h1 span.title-extra {
    color: #007bff; /* 使用主題色 */
    font-size: 0.8em; /* 練習用文字小一點 */
    font-weight: normal; /* 不加粗 */
}

/* --- 新增/修改：分類框架樣式 --- */

/* 新增：樣式化每個分類框架 */
.problem-list-frame {
    background-color: #ffffff;
    padding: 10px 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05); /* 較輕的陰影 */
    margin-bottom: 30px; /* 每個框架之間留出間隔 */
    border: 1px solid #e0e0e0; /* 加上淺色邊框 */
}

/* 樣式化新增的分類標題 */
#problemListContainer h2 {
    color: #007bff; /* 使用主題色 */
    border-bottom: 2px solid #a3ccff; /* 淺藍色分隔線 */
    padding-bottom: 5px;
    margin-top: 30px;
    margin-bottom: 10px; /* 標題與列表框架之間的間隔 */
    font-size: 1.5em;
    font-weight: 600;
}

/* 題目連結樣式 */
a {
    display: block;
    padding: 10px 0;
    margin: 0;
    text-decoration: none;
    color: #333; /* 連結文字顏色 */
    transition: background-color 0.3s ease;
    /* 淡淡的分隔線 */
    border-bottom: 1px solid #e0e0e0; /* 淡淡的灰色分隔線 */
}
/* 移除每個框架內最後一個元素底部的分隔線 */
.problem-list-frame a:last-child {
    border-bottom: none;
}
a:hover {
    text-decoration: none;
    background-color: #e6f7ff; /* 滑鼠移上時使用更淡的藍色背景 */
    color: #0056b3; /* 滑鼠移上時變深藍色 */
}
</style>
</head>
<body>

<h1>
    <span class="title-main">題目列表</span>
    <div class="title-info">
        <span class="title-email">proglohas@gmail.com</span>
        <span class="title-extra">旭光高中 / 草屯國中 Blockly 練習網站</span>
    </div>
</h1>

<div id="problemListContainer">
    
    <h2>基礎題庫</h2>
    <div id="problemList_1" class="problem-list-frame">Loading...</div>
    
    <h2>競賽題庫</h2>
    <div id="problemList_2" class="problem-list-frame">Loading...</div>
    
    <h2>UVA 題庫</h2>
    <div id="problemList_3" class="problem-list-frame">Loading...</div>
    
    <h2>不分類 / 其他</h2>
    <div id="problemList_0" class="problem-list-frame">Loading...</div>

</div>

<script>
// 定義所有可能的分類 ID 及其對應的 HTML 容器 ID
const categories = {
    '1': 'problemList_1', // 基礎題庫
    '2': 'problemList_2', // 競賽題庫
    '3': 'problemList_3', // UVA 題庫
    '0': 'problemList_0', // 不分類 / 其他 (預設)
};

// 處理初始化畫面，清除 "Loading..." 文字
Object.values(categories).forEach(id => {
    const el = document.getElementById(id);
    if (el) el.innerHTML = '';
});

fetch(`problemset.xml?ts=${Date.now()}`, { cache: "no-store" })
  .then(resp => resp.text())
  .then(str => (new DOMParser()).parseFromString(str,"text/xml"))
  .then(xml => {
    const problems = xml.getElementsByTagName('problem');

    for(let i=0;i<problems.length;i++){
      const problem = problems[i];
      const id = problem.getElementsByTagName('id')[0].textContent;
      const name = problem.getElementsByTagName('name')[0].textContent;
      
      // *** 讀取 cato 值 ***
      let catoNode = problem.getElementsByTagName('cato')[0];
      // 如果 cato 存在，取其內容，否則預設為 '0' (不分類)
      let cato = catoNode ? catoNode.textContent.trim() : '0';
      
      // 根據 cato 值決定要附加到哪一個容器
      // 如果 cato 不在 categories 列表中，也導向 '0'
      const targetListId = categories[cato] || categories['0']; 
      const listDiv = document.getElementById(targetListId);
      
      if (!listDiv) {
          console.error(`找不到 ID 為 ${targetListId} 的容器，請檢查 HTML 結構。`);
          continue; 
      }
      
      const a = document.createElement('a');

      // 產生 5 碼亂數字串
      const rand = Math.random().toString(36).substring(2, 7);

      // 新視窗 + 避免快取
      a.href = `train.html?id=${id}&v=${rand}`;
      a.target = "_blank";

      a.textContent = `${id} - ${name}`;
      listDiv.appendChild(a);
    }
  })
  .catch(err => { 
    console.error(err); 
    // 如果讀取失敗，所有容器都顯示錯誤訊息
    Object.values(categories).forEach(id => {
        const el = document.getElementById(id);
        if (el) el.textContent='讀取 XML 錯誤';
    });
});
</script>
</body>
</html>
